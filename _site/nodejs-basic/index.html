<!DOCTYPE html>
<html>
<head>
    <!--
    * Author:         MicLee
    -->
    <meta charset="utf-8" />
    <title>Node.js 概述 | MicLee's Blog</title>
    <meta name="author" content="MicLee" />
    <meta name="renderer" content="webkit">
    <meta name="description" content="MicLee's Blog" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <link rel="stylesheet" href="/css/default.css" type="text/css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
    <link rel="alternate" type="application/atom+xml" title="Recent Entries" href="/atom.xml" />
    <script src="/js/jquery-1.7.1.min.js" type="text/javascript"></script>
</head>
<body>

    <div class="home-menu">
        <div class="home-icon-con">
            <a class="home-menu-icon" href="/">MicLee</a>
            <a class="home-follow" href="#" title="Contact Me">+</a>
        </div>
        <div class="home-contact">
            <a href="http://www.weibo.com/helloensen/" target="_blank" style="margin-left:-5px;"><img src="http://www.weibo.com/favicon.ico" alt="" width="25"/></a>
            <a href="http://github.com/OfMicLee/" target="_blank" style="text-align:center;"><img src="/images/github.ico" alt="" width="22"/></a>
           <!--  <a href="http://instagram.com/miclee/" target="_blank" style="text-align:right"><img src="http://d36xtkk24g8jdx.cloudfront.net/bluebar/00c6602/images/ico/favicon.ico" alt="" width="22"/></a>
	  -->       
 	</div>
    </div>

    <link rel="stylesheet" href="/js/prettify/prettify.css" />
<style type="text/css">
    body { background:#e8e8e8; }
    @media screen and (max-width: 750px){
        body { background:#fff; }
    }
    @media screen and (max-width: 1020px){
        body { background:#fff; }
    }
</style>

<div id="content">
    <div class="entry">
        <h1 class="entry-title"><a href="/nodejs-basic" title="Node.js 概述">Node.js 概述</a></h1>
        <p class="entry-date">2015-05-19 <a href="http://github.com/OfMicLee">MicLee</a></p>
        <h2>简介</h2>

<p>Node是JavaScript语言的服务器运行环境。所谓“运行环境”有两层意思：首先，JavaScript语言通过Node在服务器运行，在这个意义上，Node有点像JavaScript虚拟机；其次，Node提供大量工具库，使得JavaScript语言与操作系统互动（比如读写文件、新建子进程），在这个意义上，Node又是JavaScript的工具库。</p>

<p>Node内部采用Google公司的V8引擎，作为JavaScript语言解释器；通过自行开发的libuv库，调用操作系统资源。</p>

<h3>安装与更新</h3>

<p>访问官方网站<a href="http://nodejs.org">nodejs.org</a>了解安装细节。</p>

<p>安装完成以后，运行下面的命令，查看是否能正常运行。</p>

<pre><code class="bash">$ node --version
# 或者
$ node -v
</code></pre>

<p>更新node.js版本，可以通过node.js的n模块完成。</p>

<pre><code class="bash">$ sudo npm install n -g
$ sudo n stable
</code></pre>

<p>上面代码通过n模块，将node.js更新为最新发布的稳定版。</p>

<p>n模块也可以指定安装特定版本的node。</p>

<pre><code class="bash">$ sudo n 0.10.21
</code></pre>

<h3>版本管理工具nvm</h3>

<p>如果想在同一台机器，同时安装多个版本的node.js，就需要用到版本管理工具nvm。</p>

<pre><code class="bash">$ git clone https://github.com/creationix/nvm.git ~/.nvm
$ source ~/.nvm/nvm.sh
</code></pre>

<p>安装以后，nvm的执行脚本，每次使用前都要激活，建议将其加入~/.bashrc文件（假定使用Bash）。激活后，就可以安装指定版本的Node。</p>

<pre><code class="bash"># 安装最新版本
$ nvm install node

# 安装指定版本
$ nvm install 0.12.1

# 使用已安装的最新版本
$ nvm use node

# 使用指定版本的node
$ nvm use 0.12
</code></pre>

<p>nvm也允许进入指定版本的REPL环境。</p>

<pre><code class="bash">$ nvm run 0.12
</code></pre>

<p>如果在项目根目录下新建一个.nvmrc文件，将版本号写入其中，就只输入<code>nvm use</code>命令即可，不再需要附加版本号。</p>

<p>下面是其他经常用到的命令。</p>

<pre><code class="bash"># 查看本地安装的所有版本
$ nvm ls

# 查看服务器上所有可供安装的版本。
$ nvm ls-remote

# 退出已经激活的nvm，使用deactivate命令。
$ nvm deactivate
</code></pre>

<h3>基本用法</h3>

<p>安装完成后，运行node.js程序，就是使用node命令读取JavaScript脚本。</p>

<p>假定当前目录有一个demo.js的脚本文件，运行时这样写。</p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash">node demo

// 或者

node demo.js</code></pre></div>


<h3>REPL环境</h3>

<p>在命令行键入node命令，后面没有文件名，就进入一个Node.js的REPL环境（Read–eval–print loop，"读取-求值-输出"循环），可以直接运行各种JavaScript命令。</p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>node
&gt; 1+1
2
&gt;</code></pre></div>


<p>如果使用参数 --use_strict，则REPL将在严格模式下运行。</p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>node --use_strict</code></pre></div>


<p>REPL是Node.js与用户互动的shell，各种基本的shell功能都可以在里面使用，比如使用上下方向键遍历曾经使用过的命令。</p>

<p>特殊变量下划线（_）表示上一个命令的返回结果。</p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash">&gt; 1+1
2
&gt; _+1
3</code></pre></div>


<p>在REPL中，如果运行一个表达式，会直接在命令行返回结果。如果运行一条语句，就不会有任何输出，因为语句没有返回值。</p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash">&gt; <span class="nv">x</span> <span class="o">=</span> 1
1
&gt; var <span class="nv">x</span> <span class="o">=</span> 1</code></pre></div>


<p>上面代码的第二条命令，没有显示任何结果。因为这是一条语句，不是表达式，所以没有返回值。</p>

<h3>异步操作</h3>

<p>Node采用V8引擎处理JavaScript脚本，最大特点就是单线程运行，一次只能运行一个任务。这导致Node大量采用异步操作（asynchronous opertion），即任务不是马上执行，而是插在任务队列的尾部，等到前面的任务运行完后再执行。</p>

<p>由于这种特性，某一个任务的后续操作，往往采用回调函数（callback）的形式进行定义。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">isTrue</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">value</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">value</span> <span class="o">===</span> <span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">callback</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="s2">&quot;Value was true.&quot;</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="nx">callback</span><span class="p">(</span><span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s2">&quot;Value is not true!&quot;</span><span class="p">));</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></div>


<p>上面代码就把进一步的处理，交给回调函数callback。</p>

<p>Node约定，如果某个函数需要回调函数作为参数，则回调函数是最后一个参数。另外，回调函数本身的第一个参数，约定为上一步传入的错误对象。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">callback</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">error</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">error</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>


<p>上面代码中，callback的第一个参数是Error对象，第二个参数才是真正的数据参数。这是因为回调函数主要用于异步操作，当回调函数运行时，前期的操作早结束了，错误的执行栈早就不存在了，传统的错误捕捉机制try...catch对于异步操作行不通，所以只能把错误交给回调函数处理。</p>

<pre><code class="javascript">try {
  db.User.get(userId, function(err, user) {
    if(err) {
      throw err
    }
    // ...
  })
} catch(e) {
  console.log(‘Oh no!’);
}
</code></pre>

<p>上面代码中，db.User.get方法是一个异步操作，等到抛出错误时，可能它所在的try...catch代码块早就运行结束了，这会导致错误无法被捕捉。所以，Node统一规定，一旦异步操作发生错误，就把错误对象传递到回调函数。</p>

<p>如果没有发生错误，回调函数的第一个参数就传入null。这种写法有一个很大的好处，就是说只要判断回调函数的第一个参数，就知道有没有出错，如果不是null，就肯定出错了。另外，这样还可以层层传递错误。</p>

<pre><code class="javascript">if(err) {
  // 除了放过No Permission错误意外，其他错误传给下一个回调函数
  if(!err.noPermission) {
    return next(err);
  }
}
</code></pre>

<h3>全局对象和全局变量</h3>

<p>Node提供以下几个全局对象，它们是所有模块都可以调用的。</p>

<ul>
<li><p><strong>global</strong>：表示Node所在的全局环境，类似于浏览器的window对象。需要注意的是，如果在浏览器中声明一个全局变量，实际上是声明了一个全局对象的属性，比如<code>var x = 1</code>等同于设置<code>window.x = 1</code>，但是Node不是这样，至少在模块中不是这样（REPL环境的行为与浏览器一致）。在模块文件中，声明<code>var x = 1</code>，该变量不是<code>global</code>对象的属性，<code>global.x</code>等于undefined。这是因为模块的全局变量都是该模块私有的，其他模块无法取到。</p></li>
<li><p><strong>process</strong>：该对象表示Node所处的当前进程，允许开发者与该进程互动。</p></li>
<li><p><strong>console</strong>：指向Node内置的console模块，提供命令行环境中的标准输入、标准输出功能。</p></li>
</ul>


<p>Node还提供一些全局函数。</p>

<ul>
<li><strong>setTimeout()</strong>：用于在指定毫秒之后，运行回调函数。实际的调用间隔，还取决于系统因素。间隔的毫秒数在1毫秒到2,147,483,647毫秒（约24.8天）之间。如果超过这个范围，会被自动改为1毫秒。该方法返回一个整数，代表这个新建定时器的编号。</li>
<li><strong>clearTimeout()</strong>：用于终止一个setTimeout方法新建的定时器。</li>
<li><strong>setInterval()</strong>：用于每隔一定毫秒调用回调函数。由于系统因素，可能无法保证每次调用之间正好间隔指定的毫秒数，但只会多于这个间隔，而不会少于它。指定的毫秒数必须是1到2,147,483,647（大约24.8天）之间的整数，如果超过这个范围，会被自动改为1毫秒。该方法返回一个整数，代表这个新建定时器的编号。</li>
<li><strong>clearInterval()</strong>：终止一个用setInterval方法新建的定时器。</li>
<li><strong>require()</strong>：用于加载模块。</li>
<li><strong>Buffer()</strong>：用于操作二进制数据。</li>
</ul>


<p>Node提供两个全局变量，都以两个下划线开头。</p>

<ul>
<li><strong>_filename</strong>：指向当前运行的脚本文件名。</li>
<li><strong>_dirname</strong>：指向当前运行的脚本所在的目录。</li>
</ul>


<p>除此之外，还有一些对象实际上是模块内部的局部变量，指向的对象根据模块不同而不同，但是所有模块都适用，可以看作是伪全局变量，主要为module, module.exports, exports等。</p>

<h2>模块化结构</h2>

<h3>概述</h3>

<p>Node.js采用模块化结构，按照<a href="http://wiki.commonjs.org/wiki/CommonJS">CommonJS规范</a>定义和使用模块。模块与文件是一一对应关系，即加载一个模块，实际上就是加载对应的一个模块文件。</p>

<p>require命令用于指定加载模块，加载时可以省略脚本文件的后缀名。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">circle</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;./circle.js&#39;</span><span class="p">);</span>
<span class="c1">// 或者</span>
<span class="kd">var</span> <span class="nx">circle</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;./circle&#39;</span><span class="p">);</span></code></pre></div>


<p>require方法的参数是模块文件的名字。它分成两种情况，第一种情况是参数中含有文件路径（比如上例），这时路径是相对于当前脚本所在的目录，第二种情况是参数中不含有文件路径，这时Node到模块的安装目录，去寻找已安装的模块（比如下例）。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">bar</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;bar&#39;</span><span class="p">);</span></code></pre></div>


<p>有时候，一个模块本身就是一个目录，目录中包含多个文件。这时候，Node在package.json文件中，寻找main属性所指明的模块入口文件。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="p">{</span>
  <span class="s2">&quot;name&quot;</span> <span class="o">:</span> <span class="s2">&quot;bar&quot;</span><span class="p">,</span>
  <span class="s2">&quot;main&quot;</span> <span class="o">:</span> <span class="s2">&quot;./lib/bar.js&quot;</span>
<span class="p">}</span></code></pre></div>


<p>上面代码中，模块的启动文件为lib子目录下的bar.js。当使用<code>require('bar')</code>命令加载该模块时，实际上加载的是<code>./node_modules/bar/lib/bar.js</code>文件。下面写法会起到同样效果。</p>

<pre><code class="javascript">
var bar = require('bar/lib/bar.js')
</code></pre>

<p>如果模块目录中没有package.json文件，node.js会尝试在模块目录中寻找index.js或index.node文件进行加载。</p>

<p>模块一旦被加载以后，就会被系统缓存。如果第二次还加载该模块，则会返回缓存中的版本，这意味着模块实际上只会执行一次。如果希望模块执行多次，则可以让模块返回一个函数，然后多次调用该函数。</p>

<h3>核心模块</h3>

<p>如果只是在服务器运行JavaScript代码，用处并不大，因为服务器脚本语言已经有很多种了。Node.js的用处在于，它本身还提供了一系列功能模块，与操作系统互动。这些核心的功能模块，不用安装就可以使用，下面是它们的清单。</p>

<ul>
<li><strong>http</strong>：提供HTTP服务器功能。</li>
<li><strong>url</strong>：解析URL。</li>
<li><strong>fs</strong>：与文件系统交互。</li>
<li><strong>querystring</strong>：解析URL的查询字符串。</li>
<li><strong>child_process</strong>：新建子进程。</li>
<li><strong>util</strong>：提供一系列实用小工具。</li>
<li><strong>path</strong>：处理文件路径。</li>
<li><strong>crypto</strong>：提供加密和解密功能，基本上是对OpenSSL的包装。</li>
</ul>


<p>上面这些核心模块，源码都在Node的lib子目录中。为了提高运行速度，它们安装时都会被编译成二进制文件。</p>

<p>核心模块总是最优先加载的。如果你自己写了一个HTTP模块，<code>require('http')</code>加载的还是核心模块。</p>

<h3>自定义模块</h3>

<p>Node模块采用CommonJS规范。只要符合这个规范，就可以自定义模块。</p>

<p>下面是一个最简单的模块，假定新建一个foo.js文件，写入以下内容。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// foo.js</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
<span class="p">};</span></code></pre></div>


<p>上面代码就是一个模块，它通过module.exports变量，对外输出一个方法。</p>

<p>这个模块的使用方法如下。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// index.js</span>

<span class="kd">var</span> <span class="nx">m</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;./foo&#39;</span><span class="p">);</span>

<span class="nx">m</span><span class="p">(</span><span class="s2">&quot;这是自定义模块&quot;</span><span class="p">);</span></code></pre></div>


<p>上面代码通过require命令加载模块文件foo.js（后缀名省略），将模块的对外接口输出到变量m，然后调用m。这时，在命令行下运行index.js，屏幕上就会输出“这是自定义模块”。</p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>node index
这是自定义模块</code></pre></div>


<p>module变量是整个模块文件的顶层变量，它的exports属性就是模块向外输出的接口。如果直接输出一个函数（就像上面的foo.js），那么调用模块就是调用一个函数。但是，模块也可以输出一个对象。下面对foo.js进行改写。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// foo.js</span>

<span class="kd">var</span> <span class="nx">out</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Object</span><span class="p">();</span>

<span class="kd">function</span> <span class="nx">p</span><span class="p">(</span><span class="nx">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">string</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">out</span><span class="p">.</span><span class="nx">print</span> <span class="o">=</span> <span class="nx">p</span><span class="p">;</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nx">out</span><span class="p">;</span></code></pre></div>


<p>上面的代码表示模块输出out对象，该对象有一个print属性，指向一个函数。下面是这个模块的使用方法。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// index.js</span>

<span class="kd">var</span> <span class="nx">m</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;./foo&#39;</span><span class="p">);</span>

<span class="nx">m</span><span class="p">.</span><span class="nx">print</span><span class="p">(</span><span class="s2">&quot;这是自定义模块&quot;</span><span class="p">);</span></code></pre></div>


<p>上面代码表示，由于具体的方法定义在模块的print属性上，所以必须显式调用print属性。</p>

<h2>http模块</h2>

<h3>基本用法</h3>

<p>http模块主要用于搭建HTTP服务。使用Node.js搭建HTTP服务器非常简单。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">http</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;http&#39;</span><span class="p">);</span>

<span class="nx">http</span><span class="p">.</span><span class="nx">createServer</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">request</span><span class="p">,</span> <span class="nx">response</span><span class="p">){</span>
  <span class="nx">response</span><span class="p">.</span><span class="nx">writeHead</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;Content-Type&#39;</span><span class="o">:</span> <span class="s1">&#39;text/plain&#39;</span><span class="p">});</span>
  <span class="nx">response</span><span class="p">.</span><span class="nx">end</span><span class="p">(</span><span class="s1">&#39;Hello World\n&#39;</span><span class="p">);</span>
<span class="p">}).</span><span class="nx">listen</span><span class="p">(</span><span class="mi">8080</span><span class="p">,</span> <span class="s2">&quot;127.0.0.1&quot;</span><span class="p">);</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Server running on port 8080.&#39;</span><span class="p">);</span></code></pre></div>


<p>上面代码第一行<code>var http = require("http")</code>，表示加载http模块。然后，调用http模块的createServer方法，创造一个服务器实例，将它赋给变量http。</p>

<p>ceateServer方法接受一个函数作为参数，该函数的request参数是一个对象，表示客户端的HTTP请求；response参数也是一个对象，表示服务器端的HTTP回应。response.writeHead方法表示，服务器端回应一个HTTP头信息；response.end方法表示，服务器端回应的具体内容，以及回应完成后关闭本次对话。最后的listen(8080)表示启动服务器实例，监听本机的8080端口。</p>

<p>将上面这几行代码保存成文件app.js，然后用node调用这个文件，服务器就开始运行了。</p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>node app.js</code></pre></div>


<p>这时命令行窗口将显示一行提示“Server running at port 8080.”。打开浏览器，访问http://localhost:8080，网页显示“Hello world!”。</p>

<p>上面的例子是当场生成网页，也可以事前写好网页，存在文件中，然后利用fs模块读取网页文件，将其返回。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">http</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;http&#39;</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">fs</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;fs&#39;</span><span class="p">);</span>

<span class="nx">http</span><span class="p">.</span><span class="nx">createServer</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">request</span><span class="p">,</span> <span class="nx">response</span><span class="p">){</span>
  <span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">(</span><span class="s1">&#39;data.txt&#39;</span><span class="p">,</span> <span class="kd">function</span> <span class="nx">readData</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">response</span><span class="p">.</span><span class="nx">writeHead</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;Content-Type&#39;</span><span class="o">:</span> <span class="s1">&#39;text/plain&#39;</span><span class="p">});</span>
    <span class="nx">response</span><span class="p">.</span><span class="nx">end</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span>
  <span class="p">});</span>
<span class="p">}).</span><span class="nx">listen</span><span class="p">(</span><span class="mi">8080</span><span class="p">,</span> <span class="s2">&quot;127.0.0.1&quot;</span><span class="p">);</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Server running on port 8080.&#39;</span><span class="p">);</span></code></pre></div>


<p>下面的修改则是根据不同网址的请求，显示不同的内容，已经相当于做出一个网站的雏形了。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">http</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s2">&quot;http&quot;</span><span class="p">);</span>

<span class="nx">http</span><span class="p">.</span><span class="nx">createServer</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="p">{</span>

  <span class="c1">// 主页</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">url</span> <span class="o">==</span> <span class="s2">&quot;/&quot;</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">res</span><span class="p">.</span><span class="nx">writeHead</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="p">{</span> <span class="s2">&quot;Content-Type&quot;</span><span class="o">:</span> <span class="s2">&quot;text/html&quot;</span> <span class="p">});</span>
    <span class="nx">res</span><span class="p">.</span><span class="nx">end</span><span class="p">(</span><span class="s2">&quot;Welcome to the homepage!&quot;</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// About页面</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nx">url</span> <span class="o">==</span> <span class="s2">&quot;/about&quot;</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">res</span><span class="p">.</span><span class="nx">writeHead</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="p">{</span> <span class="s2">&quot;Content-Type&quot;</span><span class="o">:</span> <span class="s2">&quot;text/html&quot;</span> <span class="p">});</span>
    <span class="nx">res</span><span class="p">.</span><span class="nx">end</span><span class="p">(</span><span class="s2">&quot;Welcome to the about page!&quot;</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// 404错误</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="nx">res</span><span class="p">.</span><span class="nx">writeHead</span><span class="p">(</span><span class="mi">404</span><span class="p">,</span> <span class="p">{</span> <span class="s2">&quot;Content-Type&quot;</span><span class="o">:</span> <span class="s2">&quot;text/plain&quot;</span> <span class="p">});</span>
    <span class="nx">res</span><span class="p">.</span><span class="nx">end</span><span class="p">(</span><span class="s2">&quot;404 error! File not found.&quot;</span><span class="p">);</span>
  <span class="p">}</span>

<span class="p">}).</span><span class="nx">listen</span><span class="p">(</span><span class="mi">8080</span><span class="p">,</span> <span class="s2">&quot;localhost&quot;</span><span class="p">);</span></code></pre></div>


<p>回调函数的req（request）对象，拥有以下属性。</p>

<ul>
<li>url：发出请求的网址。</li>
<li>method：HTTP请求的方法。</li>
<li>headers：HTTP请求的所有HTTP头信息。</li>
</ul>


<h3>处理POST请求</h3>

<p>当客户端采用POST方法发送数据时，服务器端可以对data和end两个事件，设立监听函数。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">http</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;http&#39;</span><span class="p">);</span>

<span class="nx">http</span><span class="p">.</span><span class="nx">createServer</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">content</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">;</span>

  <span class="nx">req</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">chunk</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">content</span> <span class="o">+=</span> <span class="nx">chunk</span><span class="p">;</span>
  <span class="p">});</span>

  <span class="nx">req</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">&#39;end&#39;</span><span class="p">,</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="nx">res</span><span class="p">.</span><span class="nx">writeHead</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;Content-Type&quot;</span><span class="o">:</span> <span class="s2">&quot;text/plain&quot;</span><span class="p">});</span>
    <span class="nx">res</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="s2">&quot;You&#39;ve sent: &quot;</span> <span class="o">+</span> <span class="nx">content</span><span class="p">);</span>
    <span class="nx">res</span><span class="p">.</span><span class="nx">end</span><span class="p">();</span>
  <span class="p">});</span>

<span class="p">}).</span><span class="nx">listen</span><span class="p">(</span><span class="mi">8080</span><span class="p">);</span></code></pre></div>


<p>data事件会在数据接收过程中，每收到一段数据就触发一次，接收到的数据被传入回调函数。end事件则是在所有数据接收完成后触发。</p>

<p>对上面代码稍加修改，就可以做出文件上传的功能。</p>

<pre><code class="javascript">
"use strict";

var http = require('http');
var fs = require('fs');
var destinationFile, fileSize, uploadedBytes;

http.createServer(function (request, response) {
  response.writeHead(200);
  destinationFile = fs.createWriteStream("destination.md");
  request.pipe(destinationFile);
  fileSize = request.headers['content-length'];
  uploadedBytes = 0;

  request.on('data', function (d) {
    uploadedBytes += d.length;
    var p = (uploadedBytes / fileSize) * 100;
    response.write("Uploading " + parseInt(p, 0) + " %\n");
  });

  request.on('end', function () {
    response.end("File Upload Complete");
  });
}).listen(3030, function () {
  console.log("server started");
});
</code></pre>

<h3>发出请求：get方法</h3>

<p>get方法用于发出get请求。</p>

<pre><code class="javascript">
function getTestPersonaLoginCredentials(callback) {
  return http.get({
    host: 'personatestuser.org',
    path: '/email'
  }, function(response) {
    var body = '';

    response.on('data', function(d) {
      body += d;
    });

    response.on('end', function() {
      var parsed = JSON.parse(body);
      callback({
        email: parsed.email,
        password: parsed.pass
      });
    });
  });
},
</code></pre>

<h3>发出请求：request方法</h3>

<p>request方法用于发出HTTP请求。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">http</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;http&#39;</span><span class="p">);</span>

<span class="c1">//The url we want is: &#39;www.random.org/integers/?num=1&amp;min=1&amp;max=10&amp;col=1&amp;base=10&amp;format=plain&amp;rnd=new&#39;</span>
<span class="kd">var</span> <span class="nx">options</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">host</span><span class="o">:</span> <span class="s1">&#39;www.random.org&#39;</span><span class="p">,</span>
  <span class="nx">path</span><span class="o">:</span> <span class="s1">&#39;/integers/?num=1&amp;min=1&amp;max=10&amp;col=1&amp;base=10&amp;format=plain&amp;rnd=new&#39;</span>
<span class="p">};</span>

<span class="nx">callback</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">response</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>

  <span class="c1">//another chunk of data has been recieved, so append it to `str`</span>
  <span class="nx">response</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">chunk</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">str</span> <span class="o">+=</span> <span class="nx">chunk</span><span class="p">;</span>
  <span class="p">});</span>

  <span class="c1">//the whole response has been recieved, so we just print it out here</span>
  <span class="nx">response</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">&#39;end&#39;</span><span class="p">,</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">str</span><span class="p">);</span>
  <span class="p">});</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">req</span> <span class="o">=</span> <span class="nx">http</span><span class="p">.</span><span class="nx">request</span><span class="p">(</span><span class="nx">options</span><span class="p">,</span> <span class="nx">callback</span><span class="p">);</span>

<span class="nx">req</span><span class="p">.</span><span class="nx">write</span><span class="p">(</span><span class="s2">&quot;hello world!&quot;</span><span class="p">);</span>
<span class="nx">req</span><span class="p">.</span><span class="nx">end</span><span class="p">();</span></code></pre></div>


<p>request对象的第一个参数是options对象，用于指定请求的域名和路径，第二个参数是请求完成后的回调函数。</p>

<p>如果使用POST方法发出请求，只需在options对象中设定即可。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">options</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">host</span><span class="o">:</span> <span class="s1">&#39;www.example.com&#39;</span><span class="p">,</span>
  <span class="nx">path</span><span class="o">:</span> <span class="s1">&#39;/&#39;</span><span class="p">,</span>
  <span class="nx">port</span><span class="o">:</span> <span class="s1">&#39;80&#39;</span><span class="p">,</span>
  <span class="nx">method</span><span class="o">:</span> <span class="s1">&#39;POST&#39;</span>
<span class="p">};</span></code></pre></div>


<p>指定HTTP头信息，也是在options对象中设定。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">options</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">headers</span><span class="o">:</span> <span class="p">{</span><span class="s1">&#39;custom&#39;</span><span class="o">:</span> <span class="s1">&#39;Custom Header Demo works&#39;</span><span class="p">}</span>
<span class="p">};</span></code></pre></div>


<h3>搭建HTTPs服务器</h3>

<p>搭建HTTPs服务器需要有SSL证书。对于向公众提供服务的网站，SSL证书需要向证书颁发机构购买；对于自用的网站，可以自制。</p>

<p>自制SSL证书需要OpenSSL，具体命令如下。</p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash">openssl genrsa -out key.pem
openssl req -new -key key.pem -out csr.pem
openssl x509 -req -days <span class="m">9999</span> -in csr.pem -signkey key.pem -out cert.pem
rm csr.pem</code></pre></div>


<p>上面的命令生成两个文件：ert.pem（证书文件）和 key.pem（私钥文件）。有了这两个文件，就可以运行HTTPs服务器了。</p>

<p>Node.js提供一个https模块，专门用于处理加密访问。</p>

<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">https</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;https&#39;</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">fs</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">&#39;fs&#39;</span><span class="p">);</span>

<span class="kd">var</span> <span class="nx">options</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">key</span><span class="o">:</span> <span class="nx">fs</span><span class="p">.</span><span class="nx">readFileSync</span><span class="p">(</span><span class="s1">&#39;key.pem&#39;</span><span class="p">),</span>
  <span class="nx">cert</span><span class="o">:</span> <span class="nx">fs</span><span class="p">.</span><span class="nx">readFileSync</span><span class="p">(</span><span class="s1">&#39;cert.pem&#39;</span><span class="p">)</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="nx">https</span><span class="p">.</span><span class="nx">createServer</span><span class="p">(</span><span class="nx">options</span><span class="p">,</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">res</span><span class="p">.</span><span class="nx">writeHead</span><span class="p">(</span><span class="mi">200</span><span class="p">);</span>
  <span class="nx">res</span><span class="p">.</span><span class="nx">end</span><span class="p">(</span><span class="s2">&quot;hello world\n&quot;</span><span class="p">);</span>
<span class="p">}).</span><span class="nx">listen</span><span class="p">(</span><span class="mi">8000</span><span class="p">);</span></code></pre></div>


<p>上面代码显示，HTTPs服务器与HTTP服务器的最大区别，就是createServer方法多了一个options参数。运行以后，就可以测试是否能够正常访问。</p>

<div class="highlight"><pre><code class="language-bash" data-lang="bash">curl -k https://localhost:8000</code></pre></div>


<h3>模块属性</h3>

<p>（1）HTTP请求的属性</p>

<ul>
<li>headers：HTTP请求的头信息。</li>
<li>url：请求的路径。</li>
</ul>


<h3>模块方法</h3>

<p>（1）http模块的方法</p>

<ul>
<li>createServer(callback)：创造服务器实例。</li>
</ul>


<p>（2）服务器实例的方法</p>

<ul>
<li>listen(port)：启动服务器监听指定端口。</li>
</ul>


<p>（3）HTTP回应的方法</p>

<ul>
<li>setHeader(key, value)：指定HTTP头信息。</li>
<li>write(str)：指定HTTP回应的内容。</li>
<li>end()：发送HTTP回应。</li>
</ul>


<h2>Buffer对象</h2>

<p>Buffer对象是Node.js用来处理二进制数据的一个接口。它是一个构造函数，它的实例代表了V8引擎分配的一段内存。</p>

<p>Buffer对象可以用new命令生成一个实例，它的参数就是存入内存的数据。</p>

<pre><code class="javascript">
var hello = new Buffer('Hello');

console.log(hello);
// &lt;Buffer 48 65 6c 6c 6f&gt;

console.log(hello.toString());
// "Hello"
</code></pre>

<p>上面代码表示，hello是一个Buffer，内容为储存在内存中的五个字符的二进制数据，使用toString方法可以看到对应的字符串。</p>

<p>toString方法可以只返回指定位置内存的内容，它的第二个参数表示起始位置，第三个参数表示终止位置，两者都是从0开始计算。</p>

<pre><code class="javascript">
var buf = new Buffer('just some data');
console.log(buf.toString('ascii', 4, 9));
// "some"
</code></pre>

<p>除了使用字符串参数，生成Buffer实例，还可以使用十六进制数据。</p>

<pre><code class="javascript">
var hello = new Buffer([0x48, 0x65, 0x6c, 0x6c, 0x6f]);
</code></pre>

<p>构造函数Buffer的参数，如果是一个数值，就表示所生成的实例占据内存多少个字节。</p>

<pre><code class="javascript">
var buf = new Buffer(5);
buf.write('He');
buf.write('l', 2);
buf.write('lo', 3);
console.log(buf.toString());
// "Hello"
</code></pre>

<p>Buffer实例的write方法，可以向所指定的内存写入数据。它的第一个参数是所写入的内容，第二个参数是所写入的起始位置（从0开始）。所以，上面代码最后写入内存的内容是Hello。</p>

<p>Buffer实例的length属性，返回Buffer实例所占据的内存长度。如果想知道一个字符串所占据的字节长度，可以将其传入Buffer.byteLength方法。</p>

<p>Buffer实例的slice方法，返回一个按照指定位置、从原对象切割出来的Buffer实例。它的两个参数分别为切割的起始位置和终止位置。</p>

<pre><code class="javascript">
var buf = new Buffer('just some data');
var chunk = buf.slice(4, 9);
console.log(chunk.toString());
// "some"
</code></pre>

<h2>异常处理</h2>

<p>Node是单线程运行环境，一旦抛出的异常没有被捕获，就会引起整个进程的崩溃。所以，Node的异常处理对于保证系统的稳定运行非常重要。</p>

<h3>try...catch结构</h3>

<p>最常用的捕获异常的方式，就是使用try...catch结构。但是，这个结构无法捕获异步运行的代码抛出的异常。</p>

<pre><code class="javascript">
try {
    process.nextTick(function () {
        throw new Error("error");
    });
} catch (err) {
    //can not catch it
    console.log(err);
}

try {
    setTimeout(function(){
        throw new Error("error");
    },1)
} catch (err) {
    //can not catch it
    console.log(err);
}
</code></pre>

<p>上面代码抛出的两个异常，都无法被catch代码块捕获。</p>

<h3>uncaughtException事件</h3>

<p>当一个异常未被捕获，就会触发uncaughtException事件，可以对这个事件注册回调函数，从而捕获异常。</p>

<pre><code class="javascript">
process.on('uncaughtException', function(err) {
    console.error('Error caught in uncaughtException event:', err);
});


try {
    setTimeout(function(){
        throw new Error("error");
    },1)
} catch (err) {
    //can not catch it
    console.log(err);
}
</code></pre>

<p>只要给uncaughtException配置了回调，Node进程不会异常退出，但异常发生的上下文已经丢失，无法给出异常发生的详细信息。而且，异常可能导致Node不能正常进行内存回收，出现内存泄露。所以，当uncaughtException触发后，最好记录错误日志，然后结束Node进程。</p>

<pre><code class="javascript">
process.on('uncaughtException', function(err) {
  logger(err);
  process.exit(1);
});
</code></pre>

<h3>正确的编码习惯</h3>

<p>由于异步中的异常无法被外部捕获，所以异常应该作为第一个参数传递给回调函数，Node的编码规则就是这么规定的。</p>

<pre><code class="javascript">
fs.readFile('/t.txt', function (err, data) {
  if (err) throw err;
  console.log(data);
});
</code></pre>

<h2>命令行脚本</h2>

<p>node脚本可以作为命令行脚本使用。</p>

<pre><code class="bash">$ node foo.js
</code></pre>

<p>上面代码执行了foo.js脚本文件。</p>

<p>foo.js文件的第一行，如果加入了解释器的位置，就可以将其作为命令行工具直接调用。</p>

<pre><code class="bash">#!/usr/bin/env node
</code></pre>

<p>调用前，需更改文件的执行权限。</p>

<pre><code class="bash">$ chmod u+x myscript.js
$ ./foo.js arg1 arg2 ...
</code></pre>

<p>作为命令行脚本时，<code>console.log</code>用于输出内容到标准输出，<code>process.stdin</code>用于读取标准输入，<code>child_process.exec()</code>用于执行一个shell命令。</p>

<h2>参考链接</h2>

<ul>
<li>Cody Lindley, <a href="http://tech.pro/tutorial/1190/package-managers-an-introductory-guide-for-the-uninitiated-front-end-developer">Package Managers: An Introductory Guide For The Uninitiated Front-End Developer</a></li>
<li>Stack Overflow, <a href="http://stackoverflow.com/questions/1884724/what-is-node-js">What is Node.js?</a></li>
<li>Andrew Burgess, <a href="http://dev.tutsplus.com/tutorials/using-nodes-event-module--net-35941">Using Node's Event Module</a></li>
<li>James Halliday, <a href="http://substack.net/task_automation_with_npm_run">task automation with npm run</a>- Romain Prieto, <a href="http://www.asyncdev.net/2013/12/working-on-related-node-modules-locally/">Working on related Node.js modules locally</a></li>
<li>Alon Salant, <a href="http://bites.goodeggs.com/posts/export-this/">Export This: Interface Design Patterns for Node.js Modules</a></li>
<li>Node.js Manual &amp; Documentation, <a href="http://nodejs.org/api/modules.html">Modules</a></li>
<li>Brent Ertz, <a href="http://quickleft.com/blog/creating-and-publishing-a-node-js-module">Creating and publishing a node.js module</a></li>
<li>Fred K Schott, <a href="http://fredkschott.com/post/2014/02/npm-no-longer-defaults-to-tildes/">"npm install --save" No Longer Using Tildes</a></li>
<li>Satans17, <a href="http://satans17.github.io/2014/05/04/node%E7%A8%B3%E5%AE%9A%E6%80%A7%E7%9A%84%E7%A0%94%E7%A9%B6%E5%BF%83%E5%BE%97/">Node稳定性的研究心得</a></li>
<li>Axel Rauschmayer, <a href="http://www.2ality.com/2011/12/nodejs-shell-scripting.html">Write your shell scripts in JavaScript, via Node.js</a></li>
</ul>


    </div>
    <!--
    <div class="sidenav">
        <iframe width="100%" height="75" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=75&fansRow=2&ptype=1&speed=0&skin=5&isTitle=0&noborder=0&isWeibo=0&isFans=0&uid=1855270953&verifier=375b89d6&dpc=1"></iframe>
    </div>-->

    <div class="sidenav">
        <h2>Blog</h2>
        <ul class="artical-list">
        
            <li><a href="/markdown-syntax">Markdown Syntax</a></li>
        
        </ul>

        <h2>Technology</h2>
        <ul class="artical-list">
        
            <li><a href="/nodejs-basic">Node.js 概述</a></li>
        
            <li><a href="/commonjs">CommonJS规范</a></li>
        
        </ul>

        <h2>Life</h2>
        <ul class="artical-list">
        
        </ul>
    </div>
</div>

<script src="/js/post.js" type="text/javascript"></script>


    <script type="text/javascript">
        $(function(){
            $('.home-follow').click(function(e){
                e.preventDefault();

                if($('.home-contact').is(':visible')){
                    $('.home-contact').slideUp(100);
                }else{
                    $('.home-contact').slideDown(100);
                }
            });
        })
    </script>
</body>
</html>
